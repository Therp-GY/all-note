# 概念

- 数据库

  长期存储在计算机内的、有组织的、可共享的数据集合。数据库中的数据按一定的数据集合。数据库中的数据按一定的数据模型组织、存储和描述，由DBMS统一管理，多用户共享。

- 数据库管理系统

  是一个通用的**软件系统**，由一组计算机**程序**构成。它能够对数据库进行有效的管理，并为用户提供了一个软件环境，方便用户使用数据库中的信息

- 数据库系统

  数据库系统是指一个计算机存储记录的系统。即，它是一个**计算机系统**，该系统的目标是存储信息并支持用户检索和更新所需要的信息。它通常由数据库，软件，硬件，用户几个部分组成。

  - 特点

    - 面向全组织的结构化
      - 支持全企业的应用而不是某一个应用
      - 统一的结构描述数据与数据之间的本质联系

    - 数据集成与共享，可控冗余度

    - 数据独立性好
      - 数据与程序相对独立

        数据库的**定义**和**描述**从应用程序中分离。数据的存取由系统管理，用户不必考虑存储路径等等，简化应用程序。

      - 数据的独立性

        数据的结构发生变化时，通过系统提供的**映像（转换）功能**，使应用程序不必改变。它包括数据的物理独立性和逻辑独立性。

    - 统一的控制机制

      - 数据的安全性控制

        保护数据以防止不合法的使用所造成的数据泄露和破坏

        措施：用户标识与鉴定，存取控制

      - 数据的完整性控制

        数据的正确性、有效性、相容性

        措施：完整性约束条件定义和检查

      - 并发控制

        对多用户的并发操作加以控制、协调，防止其互相干扰而得到错误的结果并使数据库完整性遭到破坏

        措施：封锁

      - 数据库恢复

        将数据库从错误状态恢复到某一已知的正确状态，防止数据丢失和损害，保证数据的正确性

## 数据模型

分为逻辑数据模型和概念数据模型

### 数据结构

描述数据的静态特性，是所研究的对象类型的集合，包括：

#### 数据本身

- 实体

  客观存在并且可以互相区分的事物。可以是人、事、物等等。

- 属性

  实体所具有的某一特性。如学生的姓名、学号

- 域

  属性的取值范围。

- 实体型

  用实体名与其属性名集合来抽象和刻画同类实体，称为实体型，例学生（姓名、年龄、性别）

- 实体集

  同型实体的集合

  如全体学生

- 码

  能唯一标识实体的属性集

  如学号

- 联系

  实体（型）内部的联系和实体（型）之间的联系。内部联系通常指组成实体的各属性之间的联系，实体之间联系指不同实体集之间的联系

#### 数据之间的联系

可以有一对一、一对多、多对一联系

### 数据操作

对系统的动态特性的描述，用于描述施加在数据之上的各种操作。

一般有检索、更新（增删改查）等操作。

### 数据的约束条件

数据的约束条件是完整性规则的集合，规定数据库的状态及状态变化所满足的条件，以保证数据的正确、有效、相容。

### 逻辑数据模型

- 层次模型

  - 用树结构表示实体之间联系的模型

  - 树由节点和连线组成，节点表示实体型，连线表示两个实体型间的一对多联系

  * 树特性：
    - 每棵树有且仅有一个节点无双亲节点，它叫树的根
    - 树中的其它节点都有且仅有一个双亲节点
  * **层次模型的联系类似于指针**，靠指向确定联系。

- 网状模型

  - 相比于层次模型，可以有一个以上的节点无双亲，至少有一个节点有多于一个的双亲节点（即构成图）

- 关系模型

  - 用二维表表示实体及其相互联系
  - 将之前指针表示联系转化为二维表信息，**属性和联系的表示方式变为同种方式**从而简化操作
  - 什么叫二维表：知道**行列**即可获取信息

## 数据模式

- 外模式

  用户的数据视图。是数据的局部逻辑结构，模式的子集。

- 模式

  所有用户的公共数据视图。是数据库中全体数据的全局逻辑结构和特性的描述。

- 内模式

  又称存储模式。数据的物理结构及存储方式。

- 外模式/模式映像

- 模式/内模式映像

## 数据库系统组成

- 数据库

  全组织的日常运营所需要的各种数据,包括目标数据（数据本身）及描述数据（对数据的说明信息）

- 软件

  - 数据库管理系统（DBMS）

    Oracle,Db2,Sybase,SQL Server,Informix

    --->	操纵和管理数据库的大型软件，用于建立、使用和维护数据库

  - 支持DBMS运行的操作系统

  - 具有与数据库接口的高级语言及其编译系统

  - 应用开发工具

    PB,VB,VC,DELPHIPB,VB,VC,DELPHI

  - 为特定应用环境开发的数据库应用系统

- 硬件

- 用户

# 关系数据库

## 关系数据模型

- 组成

  数据结构：二维表

  完整性约束

- 关系操作：选择、投影、连接、除、并、交、差等查询操作和增加、删除、修改操作两大部分。

  **特点**：**集合操作方式，操作的对象及结果都是集合。**

- 关系数据语言

  - 关系代数：用对关系的运算来表达查询，需要指明所用操作。
  - 关系演算：用谓词来表达查询，只需描述所需信息的特性。
  - 特点：面向集合的存取方式。非过程化。

## 数据结构

- 域

  一组具有相同的数据类型的值的集合。

- 笛卡尔积

  - 给定一组域D1 , D2 ,…, Dn，这些域中可以有相同的。 D1 , D2 ,…, Dn的笛卡尔积为:

    D1×D2×…×Dn = {(d1 , d2 , … , dn) | di∈Di , i=1,…,n}

  - 笛卡尔积的每个元素(d1 , d2 , …, dn)称作一个**n-元组**或简称**元组**。

  - 元组的每一个值di叫做一个**分量**

  - 注意：笛卡儿积中的d都是有序的，然而关系中的分量是无序的因为有属性名字标定

- 关系模型对关系的**限定**和**扩充**
  - 限定
  
    **无限关系**在数据库系统中是**无意义**的。因此，限定关系数据模型中的关系必须是**有限**、且**有意义**的集合。
  
  -  **关系的表示**
  
    通过为关系的每一个列附加一个属性名取消关系的有序性，即（d1, d2,…, di, dj, …, dn）= （d1, d2,…, dj, di, …, dn）(i,j=1,2， …,n)  --------》
  
- 关系的性质

  - 列是同质的

    每一列中的分量来自同一域，是同一类型的数据

  - 不同列可出自同一域，每列必须有不同的属性名

  - 列的顺序无关紧要，可以互换（因为属性名标定）

  - 任意两个元组不能完全相同（和 集合内无相同元素一一对应）

  - 行的顺序无关紧要，次序可换。

  - 每一分量必须是不可再分的数据。

- 关系的描述（关系模式）

  R(U, D, dom, F, I)

  R：关系名

  U：组成关系的属性名集合

  D：属性集所来自的域

  dom：属性映射到域的映像集合

  F：属性间的数据依赖关系集合

  I：完整性约束集合

  可以简记作R（A（属性名））

  - 关系数据库

    实体及实体之间的联系的关系的集合构成一个关系数据库

    - 型

      关系模式的集合，即数据库描述

    - 值

      关系模式在某一时刻对应的关系实例的集合

## 完整性约束

- 外部码

  简单理解：某个关系中的属性 是  别的关系的主码

- 参照完整性

  简单理解：例如课程表中的学生属性值必须在学生表中存在

## 关系代数

- 广义笛卡尔积重名问题

  当两个关系集（R,S）中有相同属性（B），则可以用 R.B,S.B表示新的关系中的属性

- 自然连接

  当相同属性有多个，必须同时考虑

- 复合连接

  简单理解：连接后，之前使用的的相同属性列不出现在新的集合中
  
- 除法运算

  即结果和除数相乘要被包含在被除数中

  ![1572586363742](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1572586363742.png)

- 符号 - 操作

  ∏投影     $\sigama$ 选择     ⋈连接操作
  
  
  
  理解
  
  选择、投影操作完成了对一个表的操作，连接操作将关系之间建立联系（可以是补充作用，为一个元组补充更多信息提供查询）

## SQL查询

- 关于NULL

  数据库中任何与NULL比较或者运算得到的都是不确定的值，因此可用

  is NULL 只判断是不是空值避免问题

  NVL(a,0)若a为空则取0

- SELECT语句  FROM后跟哪个表 SELECT 后跟要的哪几个属性  count等等操作将取和的操作变为一个属性  **最后返回的是元组**。

  简单的说 select决定几个列，查出来的决定几个行

- 嵌套查询中相关子查询，从外向内，外部提供给嵌套语句信息

- select 学生表$.学号, 姓名, SUM(成绩)AS 总成绩,AVG(成绩)AS 平均成绩  from 学生表$ , 选课表$ 
  where 学生表$.学号 = 选课表$.学号
  **group by  学生表$.学号, 姓名**    【group by 列名要写全】

- in只允许一个字段(列)  

  exist允许多个，意思是只要能返回一条行即真

- 嵌套子查询中的表若和外层表是同一张，可以在表后给相同的表取不同的名字区分

- ！！！查询实际上由简入繁，如   查询选修了'数据库'课程的学生的学号和获得的学分：第一层就是 将几个表连起来，然后group by 学号，求SUM(学分)，而学号又有条件约束，是选修了数据库的，再建立嵌套查询，传上来选修了数据库的学生所有学号即可。 

# 关系数据理论

目的：如何构建一个好的关系模式

## 概念

- 概念

  - 函数依赖

    函数依赖：设R(U)是属性集U上的关系模式，X , Y 是**U的子集**。若对于R(U)的**任意**一个可能的关系r，r中不可能存在两个元组在X上的**属性值**相等，而在Y上的**属性值**不等，则称X函数决定Y，或Y函数依赖于X，记作X->Y。

    - 注意X，Y是自己而不是单独的某个属性

      **依赖是两个属性集合之间的**

    - 函数依赖只有 1-1 或者 多-1 没有 多-多

    - 分类

      平凡函数依赖：X->Y,Y是X的子集

      完全函数依赖：X->Y，X的任何真子集X'【**注意X的真子集是X这个属性集合的真子集**】不满足X'->Y，则满足Y对X完全函数依赖（X-f>Y），不然是部分函数依赖（X-p>Y）

      完全函数依赖有研究的价值

  - 码

    - 候选码

      设K为R< U , F >的**属性或属性组合**， 若U对K完全**函数依赖**，则K为R的一个候选码

      （**因为是完全函数依赖，所以候选码中没有多余的属性**）

    - 超码

      U对K函数依赖，则K为R的超码。（K包含了一些不是候选码的属性）

    - 主属性

      包含在任何一个候选码中的属性

    - 非主属性

      不包含在任何一个候选码中的属性

    - 全码

      关系模式的码由整个属性组构成

  - 范式

    ![1573046625508](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573046625508.png)

    即一种规范的约束集

  - 规范化

    一个低一级范式的关系模式，通过模式分解可以转换为若干个高级范式的关系模式的集合，这一过程称作规范化。

例图

![1573047910072](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573047910072.png)

## 1NF

关系中每一分量必须是原子的，不可再分。即不能以集合、序列等作为属性值。

## 2NF

- 定义

  ![1573047597518](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573047597518.png)

  

- 修改方法

  ![1573048261231](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573048261231.png)

  将那些  部份依赖  的  非主属性  连带着和其  完全依赖的  候选码  提出去新建表

## 3NF

- 定义

  ![1573048453009](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573048453009.png)

  3NF是非主属性之间的传递关系，这让修改表的时候修改一项属性就会牵扯到其它多项属性

- 更改

  也是拆分这些非主属性，分出去的时候还得再带一个码

## BCNF

- 定义

  ![1573055713993](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573055713993.png)

  BCNF消除主属性对码的不良依赖

## 4NF

- 多值依赖

  设R(U)是属性集U上的一个关系模式，X、Y、Z是U的子集，并且Z = U – X – Y，关系模式R(U)中多值依赖X ->-> Y成立，当且仅当对R(U)的任一关系r，给定的一对（x，z）值有一组Y的值，这组值仅仅决定于x值而与z值无关。

  - 性质

    ![1573188528795](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573188528795.png)

    **函数依赖是多值依赖的特例**

  - 有效性范围

    ![1573196728989](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573196728989.png)

    最后一条，可能就有新的Z干扰

- 概念

  ![1573196242138](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573196242138.png)

- 改造方法

  分解

## 数据依赖的公理系统

### Armstrong公理

- 定义

  ![1573197073894](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573197073894.png)

- 证明

  如自反律，设t[X]=s[X]，由于Y是X的子集，有t[Y]=s[Y]，得证。

  都可以用t[属性集合]来证明

- 推理规则

  ![1573197206597](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573197206597.png)

- 属性集的闭包

  ![1573198600564](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573198600564.png)

  这里求的是所有**函数依赖于X**的**属性集合**

## 分解算法

- 作用

  增强范式等级（就如之前如何将二范式化成三范式一样，拆分）

- 概念

  ![1573486857410](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573486857410.png)

  其实就是将属性拆分，投影就是将原本的所有依赖归到拆分出的属性组中。\rou 就是属性组自然连接起来

### 无损连接分解

- 定义

  ![1573486949588](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573486949588.png)

  即各个拆分的属性连接起来能得到原来的关系

- 算法

  矩阵法，间ppt

### 保持函数依赖

- 定义

  ![1573487042411](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573487042411.png)

  容易理解，不丢失原来的函数依赖

- 算法

  - 达到3NF且保持函数依赖的分解
  - 达到3NF且同时保持无损连接与函数依赖的分解

### 达到更高范式



# 疑问

数库系统中的每个特点所采取的措施，如数据库的定义和描述，数据库的映像功能，数据库标识

![1572266048931](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1572266048931.png)

# sql server

- 存储路径

  ![1572222514544](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1572222514544.png)

- 导入方法

  数据库 -> 任务 ->导入 按照步骤即可

- 字符串 用单引号

- check添加到已有表中 如 P_Id中

  （注意换行）

  ```
  ALTER TABLE Persons
  	ADD CHECK (P_Id>0)
  ```

# 

## 作业1

```
insert into 学生表$	
	values(26,'李四','女',20,2008,'广东',06,10);
	
delete from 学生表$	
	where 学号 = 26
	
alter table 学生表$
	alter column 姓名 char(12);
	
alter table 学生表$ 
	add 电子邮箱 char(20);
	
alter table 课程表$
	add check(学分>=0 AND 学分 <= 6) 
	
create index cluster
	on 学生表$
	(学号)
9	
CREATE VIEW FIND1 (课程名,成绩)
as select 课程名,MAX(成绩) from 选课表$,课程表$
where 选课表$.课程号 = 课程表$.课程号 
group by 课程名
10
select 学生表$.学号, 姓名, SUM(成绩)AS 总成绩,AVG(成绩)AS 平均成绩  from 学生表$ , 选课表$ 
where 学生表$.学号 = 选课表$.学号
group by  学生表$.学号, 姓名
11
update 学生表$ 
set 年龄 = (select AVG(年龄) from 学生表$ where 系号 = 7)
where 系号 = 6
12
update 选课表$ 
set 成绩 = 63
where  选课表$.学号 = (select 学号 from 学生表$ where 姓名 = '曹洪')  
and 选课表$.课程号 in (select 课程号 from 课程表$ where 课程名 = '操作系统')
13
select 姓名,入学年份,籍贯 from 学生表$
14
select * from 学生表$ where 籍贯 = '山东'
15
select 学号,姓名 from 学生表$ where 年龄 <= all(select 年龄 from 学生表$)
16
select 学号 from 学生表$ 
where  学号 in (select 学号 from 选课表$ 
where 课程号 in (select 课程号 from 课程表$ where 课程名 = '数据库'))
或
select distinct 学生表$.学号 from 学生表$,课程表$,选课表$ 
where  学生表$.学号 = 选课表$.学号 and  选课表$.课程号 = 课程表$.课程号 and 课程名 = '数据库'
17
select distinct 学生表$.学号,学生表$.姓名 from 学生表$,课程表$,选课表$ 
where  学生表$.学号 = 选课表$.学号 
and  选课表$.课程号 = 课程表$.课程号 and 课程名 = '编译技术'
and 性别 = '女'
18
select distinct 课程号 from 学生表$,选课表$ 
where  学生表$.学号 = 选课表$ .学号 and
学生表$.学号 = (select 班长学号 from 学生表$ where 姓名 = '典韦') 
19
select  学号,姓名,系名 from 学生表$,系表$
where  学生表$.系号 = 系表$ .系号 and
学生表$.姓名 like '%侯_'
20
select distinct 课程名 from 课程表$
where  课程名 like 'P%L__'
21
select SUM(成绩)  from 选课表$
where  学号 = (select 学号 from 学生表$ where 姓名 = '甘宁')
22
select 姓名 from 学生表$
where exists(select * from 选课表$ 
	where 学生表$.学号 = 选课表$.学号 and 选课表$.课程号 in (select 课程号 from 课程表$ where 课程表$.课程名 = '操作系统'))
	and exists (select * from 选课表$ 
	where 学生表$.学号 = 选课表$.学号 and 选课表$.课程号 in (select 课程号 from 课程表$ where 课程表$.课程名 = '数据库'))
或
select distinct 学号 from 选课表$
where 学号 in (select 学号 from 选课表$ join 课程表$ on 选课表$.课程号 = 课程表$.课程号
				where 课程名 = '数据库'
				)
and 学号 in (select 学号 from 选课表$ join 课程表$ on 选课表$.课程号 = 课程表$.课程号
				where 课程名 = '操作系统'
				)
	 
23
select 学号,姓名 from 学生表$
where not exists(select * from 选课表$ 
				where 学生表$.学号 = 选课表$.学号 and 选课表$.课程号 in
						(select 课程号 from 课程表$
						where 课程名 = '数据库'))
24
select 姓名 from 学生表$
where exists(select * from 选课表$ 
	where 学生表$.学号 = 选课表$.学号 and 选课表$.课程号 in (select 课程号 from 课程表$ where 课程表$.课程名 = '数据库') and 选课表$.成绩 >= 60)
	and exists (select * from 选课表$ 
	where 学生表$.学号 = 选课表$.学号 and 选课表$.课程号 in (select 课程号 from 课程表$ where 课程表$.课程名 = '编译技术')and 选课表$.成绩 <= 60)
	
25
select 姓名,学号 from 学生表$
where exists(select * from 选课表$ 
	where 学生表$.学号 = 选课表$.学号 
	and 选课表$.课程号 in (select 课程号 from 课程表$ where 课程表$.课程名 = '数据库') 
	and 选课表$.成绩 < (select AVG(成绩) from 选课表$ where 选课表$.课程号 in (select 课程号 from 课程表$ where 课程表$.课程名 = '数据库')))

26
select 学号,姓名
from 学生表$ a 
where not exists (select * from 选课表$ c,学生表$ b
					where b.学号 = c.学号
					and 姓名 = '貂蝉'
					and not exists(select * from 选课表$ d
					where d.学号 = a.学号
					and d.课程号 = c.课程号))
					
		and 学号 not in (select 学号 from 选课表$
						where 课程号 not in (select 课程号 from 选课表$
											where 学号 in (select 学号 from 学生表$
															where 姓名 = '貂蝉')
											)
						)

27
select 学号,姓名
from 学生表$ a 
where not exists (select * from 选课表$ c,学生表$ b
					where b.学号 = c.学号
					and 姓名 = '貂蝉'
					and not exists(select * from 选课表$ d
					where d.学号 = a.学号
					and d.课程号 = cs.课程号))
					
		and 学号 in (select 学号 from 选课表$
						where 课程号 not in (select 课程号 from 选课表$
											where 学号 in (select 学号 from 学生表$
															where 姓名 = '貂蝉')
											)
						)
						
28.
select 系名 from 学生表$,选课表$,课程表$,Sheet1$
where 学生表$.学号 = 选课表$.学号 and 选课表$.课程号 = 课程表$.课程号 and 学生表$.系号 = Sheet1$.系号 and 课程名 = '数据库'
group by Sheet1$.系名 having AVG(成绩) >= 
		all(select AVG(成绩) from  学生表$,选课表$,课程表$,Sheet1$
where 学生表$.学号 = 选课表$.学号 and 选课表$.课程号 = 课程表$.课程号 and 学生表$.系号 = Sheet1$.系号 and 课程名 = '数据库' group by 系名 )

29.
select 课程名,籍贯 from 学生表$,选课表$,课程表$
where 学生表$.学号 = 选课表$.学号 and 选课表$.课程号 = 课程表$.课程号 and 籍贯 = '甘肃'
group by 课程名,籍贯 

30.
select 学生表$.学号,SUM(学分) from 学生表$,选课表$,课程表$
where 学生表$.学号 = 选课表$.学号 and 选课表$.课程号 = 课程表$.课程号
and 学生表$.学号 in (select 学生表$.学号 from 学生表$,选课表$,课程表$
where 学生表$.学号 = 选课表$.学号 and 选课表$.课程号 = 课程表$.课程号  and 课程名 = '数据库'
group by 学生表$.学号) group by 学生表$.学号

```

# 课设

## 系统设计报告模板

- 数据流图

  ![1573042556324](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573042556324.png)

- 元素表

  ![1573042570463](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573042570463.png)

- E-R图

  ![1573042585843](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573042585843.png)

- 关系模式

  ![1573042625767](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573042625767.png)

## 系统实现总结报告模板

## 想法

- 软件

  XAMPP,PHP

  ERWIN,POWERDESIGNER

- 需求分析

  一、 用户相关功能
  1. 登录：前端输入用户名和密码，在数据库中完成查询，如果存在该用户，
  则登陆成功，继续其他操作；如果不存在，则登录失败，提示用户名/密
  码错误。
  2. 注册：前端输入用户名，手机号，邮箱，密码，确认密码。
  如果用户名可用，密码与确认密码相同，则注册成功，允许登录。用户
  名已存在则提示用户名不可用。
  3. 注销：当用户注销时，确认后退出当前登录状态。
  4. 查询与更改个人信息：允许用户查看以及更改自己个人信息，应显示用
  户的用户名、手机号、邮箱等信息，可以重新编辑手机号和邮箱和密码，
  保存后更新个人信息。

  二、 饰品市场浏览功能
  1. 展示：每个饰品显示的内容有：饰品名称、种类、品质、类别、外观、价格这几种信息。
  2. 搜索：在页面顶部应有搜索栏，可按照饰品进行搜索，也可根据搜索栏的各项分类信息进行筛选，也可根据价格筛选区间。
  3. 详细信息：用户点击饰品名称之后，进入饰品的详细界面，展示饰品的细节等。

  三、 库存相关功能

  1. 展示：每个饰品显示的内容有：饰品名称、种类、品质、类别、外观、价格这几种信息。
  2. 搜索：在页面顶部应有搜索栏，可按照饰品进行搜索，也可根据搜索栏的各项分类信息进行筛选，也可根据价格筛选区间。
  3. 出售：对于用户自己的库存，可以选择出售操作，确认出售后库存信息将删除此物品，并放到自己的出售栏中，并且在市场中可以看到此商品信息