# 概述

## 基本概念

- 源程序

  用汇编或者高级语言编写的程序

- 目标程序

  用目标语言所表示的程序（目标语言：介于源语言和机器语言之间的“中间语言”，可以是某机器的机器语言，也可以是某机器的汇编语言）

  - 翻译	程序

  将源程序转换为目标程序的程序。指各个语言的翻译器，包括汇编程序和编译程序，是汇编程序、编译程序以及各种变换程序的总称

  - 汇编程序

    若源程序由汇编语言书写，经过翻译程序得到用机器语言表示的程序，这时**翻译程序**就称之为**汇编程序**，这种翻译过程称为“汇编”

  - 编译程序

    源程序用高级语言书写，经加工得到目标程序，这种翻译过程叫“编译”

  ![1567667271791](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1567667271791.png)

## 编译过程

- 编译过程是指将高级语言程序翻译为等价的目标程序的过程

### 词法分析

- 任务

  分析和识别单词。

  源程序由字符序列构成的，词法分析扫描源程序（字符串），根据语言的词法规则分析识别单词，并以某种编码形式输出

- 词法分析程序

  状态图、手工编写程序

### 语法分析

- 任务

  根据**语法规则**，分析并识出各种**语法成分**（表达式、各种说明、语句），并进行语法的**正确性检查**

- 语法分析程序

  递归子程序，编写程序

### 语义分析、生成中间代码

- 任务

  对识别出的语法成分进行语义分析，并产生相应的**中间代码**

  - 中间代码

    介于源语言和目标语言的中间语言形式

  - 目的

    便于做优化处理；

    便于编译程序的移植；（面向多个机器）

- 语法制导的翻译（属性翻译文法）

### 代码优化

- 任务

  得到高质量的代码

### 生成目标程序

和机器密切相关，根据机器进行，在做这部分工作时也可以进行优化处理。

## 贯穿编译过程

上述五个操作依次进行，而贯穿这五个操作之中还有两个不得不进行的操作

### *符号表管理

整个编译操作都贯穿**建表**和**查表**的工作。

及时把源程序中的信息和编译过程中产生的信息登记在表格中，随后要不断用到。

### *出错处理

诊察出错误，报告用户错误的性质和位置。

# 2.文法和语言的概念表示

## 形式语言基础

### 字母表和符号串

### 符号串和符号串集合的运算

#### 4.符号串集合的乘积运算

注意这里的乘积和集合的乘积不同，它是字符串的联接而不是集合的乘积

#### 6.符号串集合的闭包运算

- A＋＝A1∪A2∪A3∪......∪An∪......

  正闭包

- A*＝A0∪A＋

  闭包

## 文法的非形式讨论

- 什么是文法

  文法是对语言结构的定义与描述。即从形式上用于描述和规定语言结构的称为“文法”（或称为“语法”）

- 语法规则

  我们通过建立一组规则，来描述句子的语法结构。规定用“::=”表示“由...组成”（或“定义为...”）
  
- 由规则推导句子

  有了一组规则之后，可以按照一定的方式用它们去推导或产生句子。

  推导方法：从一个要识别的符号开始推导，即用相应规则（即上面的语法规则）的右部来替代规则的左部，每次仅用一条规则去进行推导。

### BNF的拓展

在双引号中的字("word")代表着这些字符本身。而double_quote用来代表双引号。

在双引号外的字（有可能有下划线）代表着语法部分。

尖括号( < > )内包含的为必选项。

方括号( [ ] )内包含的为可选项。

大括号( { } )内包含的为可重复0至无数次的项。

括号 () 表示分组的意思

'('等符号就表示（字符而不是别的特殊含义

竖线( | )表示在其左右两边任选一项，相当于"OR"的意思。

::= 是“被定义为”的意思。

### 文法的定义

文法G=（Vn，Vt，P，Z）

Vn：非终结符号集	

Vt：终结符号集

P：产生式或规则的集合

Z：开始符号（识别符号）Z∈Vn

v：V＝Vn∪Vt  称为文法的字 汇表

规则：U ::=xU ∈Vn,   x∈V*

### 推导的形式定义

- 定义2：

  ![1568270774537](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568270774537.png)

  这一串推导就是上面由**规则推导句子**的符号化表示

- 定义3：

  ![1568270762128](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568270762128.png)

  V+表示非空的V

- 定义4：

  ![1568270848870](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568270848870.png)

  +和*的区别就在于有没有零次推导

- 定义5：

  ![1568270930182](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568270930182.png)

  y ∈Vt*表示右侧所有符号都已经是终结符了，即每次都先把最右侧的推导完

### 语言的形式定义

- 定义6：

  ![1568271368559](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568271368559.png)

  各种句型（选择语句，循环语句） —》 各种句子（if ， for） —》 c语言

  语言是所有句子的集合

  ![1568271734357](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568271734357.png)

### 递归文法

- 递归规则：

  ![1568271881743](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568271881743.png)

- 递归文法：

  ![1568271895750](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568271895750.png)

- 例子：

  Z := B

  B := 0 | 0B

  可以用来推 00000.....0

### 句型的短语、简单短语和句柄

- 定义8：

  ![1568272181181](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568272181181.png)

  ![1568272214392](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568272214392.png)

  其中句型w是xuy，即**推导得到**的句型

  因此找句柄即找从上一句型推到这一句型中的那个简单短句（即在这个推导过程中被推导的u）

  当然U可以不仅仅是上一层的，还能使上上层

## 语法树与二义性

### 推导与语法树

- 组成：

  ![1568275214987](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568275214987.png)

- 生成：

  ![1568275234880](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568275234880.png)

  分为一般、最左、最右推导

  例子：

  ![1568291152284](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568291152284.png)

- 子树与短语

  - 子树：语法树中的某个结点（子树的根）连同它向下派生的部分所组成。（和数据结构中类似）
  - 定理：某子树的末端结点按自左向右顺序为句型中的符号串，则该符号串为该句型的相对于该子树根的短语。（好理解）
  - 只需画出句型的语法树，然后根据子树找短语→简单短语→句柄。

### 由语法树构造推导

- 归约

  自下而上地修剪子树的某些**末端结点**（**短语**），直至把整棵树剪掉（留根），每剪一次对应一次归约。

  【即将每次推导到的句型进行拆分成短语】

- 推导序列

  从句型开始，自右向左地逐步进行归约，建立推导序列。

- 规范归约

  对句型中最左简单短语（句柄）进行的归约称为规范归约。

- **规范归约**与**规范推导**互为逆过程

  规范推导从右向左推导句型---》展开树

  规范规约从左向右规约句型---》剪掉树

- 规范句型

  通过规范推导或规范归约所得到的句型称为规范句型。

# 3.词法分析

1.是什么

2.单词的分类（分类才能识别）

## 如何识别（文法识别）

**正则文法**：又称为**3型文法**。这种[文法](https://baike.baidu.com/item/文法/8974691)分为两种类型：第一类要求生成式的形式必须是A→ωB或A→ω，其中A，B都是变元，ω是[终结符](https://baike.baidu.com/item/终结符/3546704)串，这种特殊的正则文法称为右线性文法。第二类正则文法称为[左线性文法](https://baike.baidu.com/item/左线性文法/14493440)，它要求生成式必须是A→Bω，或A→ω的形式。

## 状态图

![1568859788003](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568859788003.png)

- 图的意思实际上是：

  Q推得RT，则RT才组成Q,即	Q <--- T ---- R

- 状态图的使用方法：

  利用状态图可按如下步骤分析和识别字符串x：

  1、置初始状态为当前状态，从x的最左字符开始，重复步骤2，直到x右端为止。

  2、扫描x的下一个字符，在当前状态所射出的弧中找出标记有该字符的弧，并沿此弧过渡到下一个状态；如果找不到标有该字符的弧，那么x不是句子，过程到此结束；如果扫描的是x的最右端字符，并从当前状态出发沿着标有该字符的弧过渡到下一个状态为终止状态Z，则x是句子。

  例子：

  ![1568860289085](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568860289085.png)



​		**其实上述过程就是规范规约的过程，逐一寻找句柄。   源式		子应该是从Z逐步向左推导，而现在就是从最左边当作S初		始	状态，向右规约**

- 右线性文法状态图相同，只是推导时向右，规约时向左

## 词法分析程序的设计与实现

- 选择词法有效的表示方法

  if、while等直接一对一识别

  标识符、整数常量等可采用状态图

- 同一个字符串有多个规则可以匹配

  1.长度匹配优先，即越长的越优先

  2.人为增加优先级，如定义保留字优先

- 构造词法分析程序

  - 单词及内部表示：保留字和分界符采用一符一类

  - 词法分析程序需要引用的公共（全局）变量和过程

    ![1568862667020](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1568862667020.png)

    这些变量和过程 组成 词法分析算法，当然还需要转换成c语言实现

- 词法分析算法

## 自动机

### DFA（确定的有穷状态机）

![1569297535926](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569297535926.png)

- 一个五元组确定一个DFA;
- 写自动机时先确定有几种状态，以及输入后它们各自跳转到的状态

### NFA(不确定的又穷状态机)

![1569297847401](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569297847401.png)

一个五元组确定一个NFA

其中空字符串的引入使它状态变化不确定

![1569297897221](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569297897221.png)

### NFA的确定化（转为DFA）

![1569312275142](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569312275142.png)

![1569312316631](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569312316631.png)

![1569312325511](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569312325511.png)

- 将所有状态都列举出来即可
- 然后例如{2,3}这些就是一个状态，可以在新的状态图里把它标做s1，把所有的类似这样的状态重标，这样就成为一个新的状态图

### DFA的极简化

![1569312445512](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569312445512.png)

- 由于等价必须得是同一种状态，即可接受或者不可接受状态，因此需要考察的标记只有五对

# 4.语法分析

- 概念

  根据文法规则，从源程序单词符号串中识别出语法
  成分，并进行语法检查，报告错误。

## 自顶向下分析

### 要求

- 避免二义性

  不然有多个匹配规则

  - 解决：形成优先级

    由之前句子推导的优先级相同改为优先级分层（可以引入别的符号来代表每一层的推导）

    E::= E+E | E*E | (E) | i   ------》   

    E::= E+T | T
    T ::= T*F | F
    F ::= (E) | i

    （E;T;F就代表分层）

- 左递归问题

  - 左递归：令U是文法的任一非终结符，文法中有规则
    U ∷=U¨¨或者U -+》 U¨¨

  - 左递归问题：如果在匹配输入串的过程中，假定正好轮到要用非终结符U直接匹配输入串，即要用U的右部符号串U¨¨去匹配，为了用U¨¨去匹配，又得用U去匹配，这样无限的循环下去将无法终止。

  - 消除直接左递归

    - 一、使用扩充的BNF表示来改写文法

      (1) E ∷=E+T|T ----》E ∷=T{+T}
      (2) T ∷=T\*F|T/F|F  ----》 T  ∷=F{\*F|/F}

      - 规则一（提因子）

        把 | 中相同的因子提出来

      - 规则二

        U ∷=x|y|……|z|Uv 改写为U ∷=(x|y|……|z){v}

    - 二、左递归转右递归

      - 规则三

        P ∷= Pa|b 改写为 P::= bP'   P'::= aP' | ε

  - 消除一般左递归

    ![1569651540910](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569651540910.png)

    ![1569651561706](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569651561706.png)

    ![1569651570770](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569651570770.png)

    - 其实就是换元，最后换成只有一个非终结符的递归文法再直接消除左递归

- 回溯问题(上面两项必须避免，这项不是必须避免)

  - 回溯

    - 回溯：分析工作要部分地或全部地退回去。

      例如 U::= xY | xZ ， 可能x都是符合的，然而推到xY发现错误，得清空再和xZ再匹配，又得从x开始匹配

    - 条件：文法中，对于某个非终结符号的规则其右部有多个选择，并根据所面临的输入符号不能准确地确定所要的选择时，就可能出现回溯。

    然而这会十分低效，是无实际意义的。

  - 如何避免

    U::= α1 |  α2 | α3(**注意，只要关注 | 即可**)

    FIRST(α i ) = {a | α i =*> a…, a 属于V t  }  **注意：a是最左边第一项**

    则 FIRST(α i ) ∩ FIRST(α j )=φ (i != j) 就满足

  - 消除回溯途径

    - 改写文法

      对具有多个右部的规则反复提取左因子

      U ∷=xV|xW 

      改为 U ∷=x(V|W) 

      更清楚表示为U ∷=xZ    Z ∷=V|W

      **这样就不会有重复的，因为一旦最左边第一项不同就能在第一时间排除**

    - 超前扫描

      当文法不满足避免回溯的条件时，即各选择的首符号相交时，可以采用超前扫描的方法，即向前侦察各输入符号串的第二个、第三个符号来确定要选择的目标

- 不带回溯的充分必要条件

  ![1569656785331](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569656785331.png)

  1.保证不回溯

  2.保证非左递归（看着有点晕，其实际就是满足2条件，A怎么都不会出现在最左边）

### 过程

![1569649725543](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569649725543.png)

- 语法树**末端节点**组成的句子和**输入句子**比对来确定是否成立，

  末端节点是从左向右匹配推导的（这也就导致不能处理左递归文法）

### 递归下降子程序分析法

- 具体做法

  对语法的每一个非终结符都编一个分析程序，当根据文法和当时的输入符号预测到要用某个非终结符去匹配输入串时，就调用该非终结符的分析程序。

- 步骤

  - 检查并且改写文法（无左递归，首符集不相交）

  - 检查文法递归性（是否无左递归）

    - 生成算法（注意跳转到下一个子程序接口时已经将子程序的第一个要判断的字符读入了）

    ![1569655993179](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1569655993179.png)

## 注意

- 自顶向下分析法有回溯并不算不能用，只是效率低了
- 注意，消除左递归不一定将Z转换为仅仅一行的规则，也可以是右递归形式的多行规则

- 每个递归下降子程序在最后成功判定后都会再getsym()读入操作
- 有时判断进入递归下降子程序的条件是FIRST集合

# 5.符号表

## 概述

- 是什么

  在编译过程中,编译程序用来记录源程序中各种**名字**的**特性信息**, 所以也称为名字特性表。

- 作用

  - 声明时，将声明的名字及其信息登记到符号表中

    变量：分配存储空间，并将单元地址登陆在表中

    常量：记录值

    （！！！！注意变量常量区别，这也解释为何后面存储空间的分配只有变量！！！）

  - 引用到声明的变量时进行**语法语义正确性检查**

  - 生成目标程序，需要**查符号表**取得相关信息

## 非分段

## 分段

- 函数或者过程名还是在上个表中，它们里面的变量等等名字才会在新的表中

# 6.运行时存储与管理

由于生成的目标代码是十分基础的，只有相应的地址操作等，需要用到内存的管理，因此在语义分析和生成目标代码过程中也要有运行时存储与管理。

数据存储区是否就是用来模拟运行过程中数据的取和存，代码生成时也需要存储区提供地址信息(相对地址)填入代码之中，其实它和我们mips中的存储区使用方法是一样的，函数调用需要存储区，变量调用需要存储区

## 主要问题

- **数据结构**在内存中的表示

  主要明白int、char、数组等等需要几个字节

- **函数**在内存中的表示

  函数及函数调用十分重要，有三个需求

  - 记住调用前的状态，以便调用结束返回
  - 提供一种方法，在调用函数和被调用函数之间传递**参数**，**返回值**
  - 满足scope要求，能够找到所有数据结构（比如找到上一层定义的int x）

- 它们在内存中如何**放置**和**管理**

（其实我们思考，确实重头就是 **数据结构** 和 **函数**）

**！！！！注意！！！！我们接下来的区域操作都是在数据区中**

## 静态存储分配

- 分配策略

  ![1570708300696](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1570708300696.png)

  分配的结果都在**符号表**中呈现，变量的值存储在**数据区**，而其在数据区的地址记录才在**符号表**中！

- 例子

  ![1570708347629](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1570708347629.png)

  可以看到它解决了之前的主要问题

## 动态分配

- 分配策略

  ![1570709613837](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1570709613837.png)

### 活动记录

分为：局部数据区、参数区、display区

- 局部数据区

  存放模块中定义的各个局部变量

  - 关于数组模板

    模板记录了数组的长度等等信息

- 参数区：存放隐式参数和显示参数

  ![1570709713649](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1570709713649.png)

  作用：prev abp作用于释放此数据区后数据区的指针

  ​			ret addr 用于函数的返回地址 

  ​			ret value 用于传递函数返回值

  ​			ret addr 和 ret value 的配合解决了函数执行的问题				

- display区

  存放各外层模块活动记录的基地址

  作用：查找在模块内应用但是在模块外声明定义的变量

  - 建造规则

    （1）

    ​	![1570711126094](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1570711126094.png)

    （2）

    ![1570711141800](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1570711141800.png)

  - 运行时的地址计算

    ![1570711947434](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1570711947434.png)

    BL == LEV 表示该变量就在这一层中，abp是当前运行层的基地址，也就是这一层的基地址，然后往上查找即可

    BL < LEV 表示这个变量在外层，display[BL]表示找那一层的基地址，然后往上查找即可

    **这里的地址是数据区中的地址，而(BL,ON)、nip等等怎么来的，就是靠查询符号表才得到的，我们符号表记录了函数、过程等种种信息，只要查询就能得到**

## C语言的运行时存储管理

# 7.源程序的中间形式

- 多种中间代码形式

  波兰表示、N-元组表示、抽象机表示

## 波兰表示

- 语法树 - 波兰表示

  前序遍历（根-左-右）  波兰表示

  后序遍历（左-右-根）  逆波兰表示

- （逆波兰）算法

  设一个操作符栈；当读到操作数时，立即输出该操作数，
  当扫描到操作符时，与栈顶操作符比较优先级，若栈顶操作
  符优先级高于栈外，则输出该栈顶操作符，反之，则栈外操
  作符入栈。

- IF ELSE 逆波兰式

  \<expr\><label 1 >BZ<stmt 1 ><label 2 >BR<stmt 2 >

- 还原表达式

  它的优势在于只用两种简单操作，入栈和[出栈](https://baike.baidu.com/item/出栈)就可以搞定任何普通表达式的运算。其运算方式如下：

  如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。

## N元表示

- 三元

  ![1571212434998](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571212434998.png)

  同理按照运算优先级顺序确定1、2、3、4

- 四元

  ![1571212567899](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571212567899.png)

  类似于汇编

## PC-CODE

![1571238443358](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571238443358.png)

![1571238466660](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571238466660.png)

# 8.错误处理

- 错误处理能力

  (1) 诊察错误的能力
  (2) 报错及时准确
  (3) 一次编译找出错误的多少
  (4) 错误的改正能力
  (5) 遏止重复的错误信息的能力

- 错误分类

  词法错误

  语法错误：源程序语法上不合乎文法

  语义错误：程序不符合语义规则或超越具体计算机系统限制

  - 语义规则

    • 标识符引用要符合作用域规定
    • 标识符先说明后引用
    • 参与运算的操作数类型一致
    • 过程调用时实参与形参要一致
    • 下标变量下标不能越界

  - 超越系统限制

    • 数据溢出错误
    • 符号表、静态存储分配数据区溢出
    • 动态存储分配数据区溢出

- 局部化处理

  ![1571239987983](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571239987983.png)

  ![1571239995466](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571239995466.png)

  直到停在S1或者S2再继续分析

# 9.语法制导技术

## 翻译文法

- 概念

  由原文法（输入文法）各个规则中插入动作符号，在翻译过程中就会得到输入序列 和 动作符号，

  抽去动作符号：得到输入序列（原句子）

  抽去输入序列：得到动作序列

  - 例子

    ![1571539215140](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571539215140.png)

## 属性翻译文法

- 概念

  在翻译文法基础上，翻译文法中的符号（终结符、非终结符、动作符号）都带有属性

  - 属性

    分综合属性、继承属性

    - 综合属性

      ↑表示，是自底向上

      ![1571539986328](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571539986328.png)

    - 继承属性

      ↓表示，从前面得到

      ![1571540428613](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571540428613.png)

      从前面得到的意思是，只要语法分析在它之前的都可以传入，可以是上层的也可以是同一层但在它之前的，就比如同层Type传到同层@set_table

### L-属性文法

- 属性求值规则

  ![1571547083122](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571547083122.png)

  ![1571547090783](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571547090783.png)

  自顶向下、从左往右依次继承

  自底向上、自右向左综合

  产生式见上一节

### 简单赋值的L-TAG

- 概念

  L-TAG基础上做出改变

  ![1571553545243](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571553545243.png)

  即如果有个复杂值要经过运算传入，则就找到适合位置插入运算动作，再传入

  例子

  ![1571553836552](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571553836552.png)

## 翻译文法自顶向下实现

较为容易，首先改写文法为翻译文法，然后依次翻译，遇到动作符号就操作

## 属性文法自顶向下实现

![1571555570663](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571555570663.png)

在翻译文法基础上（也需要打印动作符号），解决继承和综合的方法就是在递归子程序中加上参数的传递，继承属性直接传递确定的值给其子程序使用，综合属性传入变量在子程序中修改后再传上来



# 10.语义分析和代码生成

## 注意

1.

我们课上讲的最终翻译结果都是翻译为**栈式抽象自动机代码！！！**

![1571919964507](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571919964507.png)

其中指令的含义

![1571919983827](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571919983827.png)

即每当要运算就取运行栈中的操作数到操作栈中进行运算，然后再取回去，跳转也是在操作栈中比较（如BRF就是检查栈顶单元逻辑值，若为0就跳转）。



2.每次翻译文法的编写：考虑符号表添加、错误检查、存储区管理、代码生成

3.关于某些procedure解释

![1571920951927](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1571920951927.png)

genlab：生成跳转的标签,类似于取个标签名

emit1()：生成代码，emit就是没有操作数直接栈顶操作，emit1就是传进来一个操作数（比如标签）再进行运算

setlab：设置标号，就像我们汇编跳转程序前设置标号一样，在程序前打印上标号，其中y是个string，第一个brf中打印了一个label为y表示要跳转的地方，后头setlab就把这个y给标出来了

翻译过程中所有动作都会执行，翻译过程可没有跳转情况。。。。脑抽了都



# 11.代码优化

## 基本块内

- 复写传播：复写，由于y存在寄存器中，因此计算时用y的话不用地址访问直接用寄存器即可

- 消除公共表达式

  - ![1572851390156](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1572851390156.png)

    ![1572851403498](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1572851403498.png)

    具体操作步骤

    ![1573022807392](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573022807392.png)

    注意：

  1. 为何变量在右边时取x_0，因为变量在中间代码过程中可能也在左边出现作为赋值对象，因此取x_0代表把变量变成了常量，值为初值，后面这个变量就可以变为存储对象。

2.  x = a这种简单赋值语句只要在a所在的节点旁直接添加x即可
    
    3. 只有赋值号左边的值在查表时若查到需要改变节点号。（可以思考一下为什么，对应着代码优化的原理）
4. 注意op节点左右节点必须是i和j，这就确保表达式的正确性
   
    - 生成中间代码
    
      ![1573022893453](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573022893453.png)
    
      对应中间节点的变量集合中{t1，t2，a}如果有变量就选择变量a，没有就选一个临时寄存器t

## 全局优化

- 全局数据流分析

  - 数据流分析方程

    ![1573105828693](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573105828693.png)

    注意如果有环路需要迭代计算

    - 可达定义分析

      自上而下，由in到out

      作用：例如可分析有无死循环，如果x为true并且在循环块中再无定义，则无限循环

    - 活跃变量分析

      自下向上，由out到in

      - 作用：

        - 对分配寄存器有用。

          1.如果拥有寄存器的变量x在p点开始的任何路径上不再活跃，可以释放寄存器

          2.如果两个变量的活跃范围不重合，则可以共享同一个寄存器

          全局变量：跨越基本块的活跃变量分配到全局寄存器

          无法共享全局寄存器：活跃范围重合（冲突）

          活跃范围重合（冲突）：一个变量在另一个变量的定义点活跃，即定义语句等号右侧出现另一个变量。

          当不出现的时候，由于定义语句是**对内存操作**，**用寄存器取值然后写地址**，显然就算两个变量在一个块内，寄存器也是一语句一语句用的，因此不会冲突。

          - 变量的定义-使用链

            如何构造：同样需要gen、kill、in、out

            gen的是每条定义变量语句，kill的是别的块和这个块内定义相同变量的语句

            这样就得到每个定义变量在全局中的存活长度，只要某个块in有这个变量定义语句，说明这个定义在这个块内存在

            ![1573109355024](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573109355024.png)

            每个L都是从变量的定义点起头，通过块的所有后继找到从这个点出发的所有使用点

            可以发现同一个变量可能产生两个不相关的网，如i可以分为i1 i2用两个不同的全局寄存器

            ![1573109544267](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573109544267.png)

            通过链可以画出网图，当某个变量定义点和另一个变量使用点重合则产生冲突

      - 消除死代码

        ![1573106266065](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573106266065.png)

        红框是死代码，因为在后继代码块变量已经不活跃（不会在等式右侧使用）了，也没必要再定义（等式左侧使用）

        注意：

        - 当代码块B后继有多个的时候，活跃变量的规则是将后继的in都并起来变成B的out
  - 当代码块B的前继有多个的时候，活跃变量的规则是B的in全部传给他的所有前继
    
  
  【以上两个规则仅限于活跃变量定义，不同数据流不同规则】
      
  - 消除死代码应该再用数据流分析一边，查看有没有别的可以消除的死代码
  




# 12.代码生成

- 输入

  源程序中间表示（波兰、三元、四元、栈式中间代码）

  符号表

- 输出

  汇编、包含绝对地址的机器语言....

## 地址空间

- 代码区

- 静态数据区

  - 全局变量、静态变量、部分常量（字符串）

- 动态内存区

  - 堆

- 程序运行栈

  - 活动记录

  - **函数调用上下文现场**

    由调用方保存的一些临时寄存器、

    被调用方保存的一些全局寄存器

  **注意：运行栈的概念不是别人规定的，而是我们自己创建的，就如mips运行过程中的运行栈，都是我们自己定义的地址作为运行栈，而其它区域的具体定义也是我们来做的**

  - ![1573565972877](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573565972877.png)

    临时变量：这指的是在未在程序开头部分声明的，待使用它时才声明类型的变量。常见的如函数中定义的变量，循环语句、条件语句中声明定义的变量。这些变量可与主程序中的变量同名，在其作用区段，主程序中的同名变量一般无法调用。

## 寄存器的分配和指派

- 概念

  - 临时寄存器

    $t 调用方保存的寄存器（被调用方可以使用它们不用保留）

  - 全局寄存器

    $s 被调用方保存的寄存器

- 全局寄存器分配

  全局相对于**基本块**，而不是程序全局

  - 分配原则
    - 优先分配给跨基本块依然活跃的变量
    - 局部变量跨基本块可以分配
    - 局部变量基本块内分临时寄存器
    - 全局变量/静态变量 不参与全局寄存器分配（线程安全）
  - 启发式图着色发

- 临时寄存器分配

  - 生存范围

    不超越基本块、不跨越函数调用

  - 管理方法

    寄存器池

  - ![1573572214426](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573572214426.png)

# 理解

- 对于整个编译过程初步理解

  语法检查、符号表、存储管理、代码生成都是同时进行的，

  例如检测到变量声明，就将他记入符号表中，同时符号表划分存储地址进行存储管理，代码生成就将这个声明地址指令打印出来

  特别的，虽然我们程序运行时都是从主函数开始运行，但是我们编译就从头到尾进行翻译，因为函数的引用是靠跳转指令来进行，而和整个翻译出的目标代码顺序无关，因此目标代码只要从头到尾即可。

  - 例如函数调用时，符号表查询实参，得知地址并传入操作栈（栈式自动子），这之间符号表不产生指令，但会生成LOD等等地址操作指令，还有跳转指令跳转到被调用函数的那段目标代码，然后被调用函数有传入参数操作，.......

  - 我们要翻译的文法似乎是静态地址管理，因为没有什么动态的指令，数组定义也是直接传入整数
  - 符号表在编译结束时就销毁了，而在编译过程中其实也是不断销毁的，比如函数定义中，定义了形参a，我们会给a分配个地址，然后在后头翻译中依靠符号表找到地址，最后翻译出的目标代码都是关于a的地址的操作和符号表一点关系都没有，函数定义结束，整个函数表的符号表都能销毁了，因为目标代码中都是对地址的操作了。

  

# 课设

## pl0

error错误处理

getsym获取词

gen

## 文法解读

- 较为复杂的规则：

- ＜程序＞    ::= ［＜常量说明＞］［＜变量说明＞］{＜有返回值函数定义＞|＜无返回值函数定义＞}＜主函数＞ **yes**

  - ＜常量说明＞ ::=  const＜常量定义＞;{ const＜常量定义＞;} **yes**

    - ＜常量定义＞   ::=   int＜标识符＞＝＜整数＞{,＜标识符＞＝＜整数＞}   **yes**
                        | char＜标识符＞＝＜字符＞{,	＜标识符＞＝＜字符>}   

  - ＜变量说明＞  ::= ＜变量定义＞;{＜变量定义＞;}

    - ＜变量定义＞  ::= ＜类型标识符＞(＜标识符＞|＜标识符＞'['＜无符号整数＞']'){,(＜标识符＞|＜标识符＞'['＜无符号整数＞']' )}  **yes**

  - ＜有返回值函数定义＞  ::=  ＜声明头部＞'('＜参数表＞')' '{'＜复合语句＞'}'   **yes**

    - ＜声明头部＞   ::=  int＜标识符＞ |char＜标识符＞ 		**yes**
    
    - ＜参数表＞    ::=  ＜类型标识符＞＜标识符＞{,＜类型标识符＞＜标识符＞}| ＜空＞    **yes**
    
    - ＜复合语句＞   ::=  ［＜常量说明＞］［＜变量说明＞］＜语句列＞  **yes**
      - ＜语句列＞   ::= ｛＜语句＞｝
        - ＜语句＞    ::= ＜条件语句＞｜＜循环语句＞| '{'＜语句列＞'}'| ＜有返回值函数调用语句＞; 
                                     |＜无返回值函数调用语句＞;｜＜赋值语句＞;｜＜读语句＞;｜＜写语句＞;｜＜空＞;|＜返回语句＞;
          
          - ＜条件语句＞  ::= if '('＜条件＞')'＜语句＞［else＜语句＞］  **yes**
            - ＜条件＞    ::=  ＜表达式＞＜关系运算符＞＜表达式＞｜＜表达式＞ //表达式为0条件为假，否则为真    **yes**
              - ＜表达式＞    ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}   //[+|-]只作用于第一个<项> **yes**
                - ＜项＞     ::= ＜因子＞{＜乘法运算符＞＜因子＞} **yes**
                  - ＜因子＞    ::= ＜标识符＞｜＜标识符＞'['＜表达式＞']'|'('＜表达式＞')'｜＜整数＞|＜字符＞｜＜有返回值函数调用语句＞ **yes** 
          - ＜循环语句＞   ::=  while '('＜条件＞')'＜语句＞| do＜语句＞while '('＜条件＞')' |for'('＜标识符＞＝＜表达式＞;＜条件＞;＜标识符＞＝＜标识符＞(+|-)＜步长＞')'＜语句＞   **yes**
            
            - ＜步长＞::= ＜无符号整数＞    **yes**
          - ＜有返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'   **yes**
            
            - ＜值参数表＞   ::= ＜表达式＞{,＜表达式＞}｜＜空＞	**yes**
            
              such as :  sort(a,b)  plus(a,b*10)
          - ＜无返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'  **yes**
          - ＜赋值语句＞   ::=  ＜标识符＞＝＜表达式＞|＜标识符＞'['＜表达式＞']'=＜表达式＞  **yes**
          - ＜读语句＞    ::=  scanf '('＜标识符＞{,＜标识符＞}')'  **yes**
          - ＜写语句＞    ::= printf '(' ＜字符串＞,＜表达式＞ ')'| printf '('＜字符串＞ ')'| printf '('＜表达式＞')'  **yes**
          - ＜空＞ **yes**
          - ＜返回语句＞   ::=  return['('＜表达式＞')'] **yes**
    
  - ＜无返回值函数定义＞  ::= void＜标识符＞'('＜参数表＞')''{'＜复合语句＞'}'
  
  - ＜主函数＞    ::= void main'('')''{'＜复合语句＞'}'
  
  ```
  ＜加法运算符＞ ::= +｜-
  ＜乘法运算符＞  ::= *｜/
  ＜关系运算符＞  ::=  <｜<=｜>｜>=｜!=｜==
  ＜字母＞   ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
  ＜数字＞   ::= 0｜＜非零数字＞
  ＜非零数字＞  ::= 1｜．．．｜9
  ＜字符＞    ::=  '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'
  ＜字符串＞   ::=  "{十进制编码为32,33,35-126的ASCII字符}"
  ＜程序＞    ::= ［＜常量说明＞］［＜变量说明＞］{＜有返回值函数定义＞|＜无返回值函数定义＞}＜主函数＞
  ＜常量说明＞ ::=  const＜常量定义＞;{ const＜常量定义＞;}
  ＜常量定义＞   ::=   int＜标识符＞＝＜整数＞{,＜标识符＞＝＜整数＞}
                    | char＜标识符＞＝＜字符＞{,＜标识符＞＝＜字符＞}
  ＜无符号整数＞  ::= ＜非零数字＞｛＜数字＞｝| 0
  ＜整数＞        ::= ［＋｜－］＜无符号整数＞
  ＜标识符＞    ::=  ＜字母＞｛＜字母＞｜＜数字＞｝
  ＜声明头部＞   ::=  int＜标识符＞ |char＜标识符＞
  ＜变量说明＞  ::= ＜变量定义＞;{＜变量定义＞;}
  ＜变量定义＞  ::= ＜类型标识符＞(＜标识符＞|＜标识符＞'['＜无符号整数＞']'){,(＜标识符＞|＜标识符＞'['＜无符号整数＞']' )} 
                   //＜无符号整数＞表示数组元素的个数，其值需大于0
  ＜类型标识符＞      ::=  int | char
  ＜有返回值函数定义＞  ::=  ＜声明头部＞'('＜参数表＞')' '{'＜复合语句＞'}'
  ＜无返回值函数定义＞  ::= void＜标识符＞'('＜参数表＞')''{'＜复合语句＞'}'
  ＜复合语句＞   ::=  ［＜常量说明＞］［＜变量说明＞］＜语句列＞
  ＜参数表＞    ::=  ＜类型标识符＞＜标识符＞{,＜类型标识符＞＜标识符＞}| ＜空＞
  ＜主函数＞    ::= void main'('')''{'＜复合语句＞'}'
  ＜表达式＞    ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}   //[+|-]只作用于第一个<项>
  ＜项＞     ::= ＜因子＞{＜乘法运算符＞＜因子＞}
  ＜因子＞    ::= ＜标识符＞｜＜标识符＞'['＜表达式＞']'|'('＜表达式＞')'｜＜整数＞|＜字符＞｜＜有返回值函数调用语句＞         
  ＜语句＞    ::= ＜条件语句＞｜＜循环语句＞| '{'＜语句列＞'}'| ＜有返回值函数调用语句＞; 
                             |＜无返回值函数调用语句＞;｜＜赋值语句＞;｜＜读语句＞;｜＜写语句＞;｜＜空＞;|＜返回语句＞;
  ＜赋值语句＞   ::=  ＜标识符＞＝＜表达式＞|＜标识符＞'['＜表达式＞']'=＜表达式＞
  ＜条件语句＞  ::= if '('＜条件＞')'＜语句＞［else＜语句＞］
  ＜条件＞    ::=  ＜表达式＞＜关系运算符＞＜表达式＞｜＜表达式＞ //表达式为0条件为假，否则为真
  ＜循环语句＞   ::=  while '('＜条件＞')'＜语句＞| do＜语句＞while '('＜条件＞')' |for'('＜标识符＞＝＜表达式＞;＜条件＞;＜标识符＞＝＜标识符＞(+|-)＜步长＞')'＜语句＞
  ＜步长＞::= ＜无符号整数＞  
  ＜有返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'
  ＜无返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'
  ＜值参数表＞   ::= ＜表达式＞{,＜表达式＞}｜＜空＞
  ＜语句列＞   ::= ｛＜语句＞｝
  ＜读语句＞    ::=  scanf '('＜标识符＞{,＜标识符＞}')'
  ＜写语句＞    ::= printf '(' ＜字符串＞,＜表达式＞ ')'| printf '('＜字符串＞ ')'| printf '('＜表达式＞')'
  ＜返回语句＞   ::=  return['('＜表达式＞')']
  ```

- 一些其他的规则
  1. 只在表达式计算中有类型转换，字符型一旦参与运算则转换成整型，包括小括号括起来的字符型，也算参与了运算，例如(‘c’)的结果是整型。
  2. 其他情况，例如赋值、函数传参、if/while条件语句中关系比较要求类型完全匹配，并且＜条件＞中的关系比较只能是整型之间比，不能是字符型，if ‘(’＜条件＞‘)’和while ‘(’＜条件＞‘)’里边，如果<条件>是单个表达式，则必须是整型。
  例如：
      int a;
      a=’c’;  // 错误
      if((‘c’))  // 是合理的情况
      if (‘a’>’b’)  // 不合理
      int func()
      {
      return (‘c’);  这里需要报错
      }

### 思路

- 每要完成一项，就新开一个，不要再源代码上修改减少耦合。

  例如我每次都新开一个void函数，内部补充所缺的规则。

- 注意 空语句得加一个分号

- a|b|c.....  其中每个字母都得补全

## 词法分析

＜标识符＞    ::=  ＜字母＞｛＜字母＞｜＜数字＞｝

＜无符号整数＞  ::= ＜非零数字＞｛＜数字＞｝| 0

＜字符＞    ::=  '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'

＜字符串＞   ::=  "{十进制编码为32,33,35-126的ASCII字符}"

！！注意没有制表、换行、回车、引号

- 补

  ＜字母＞   ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
  
  ＜数字＞   ::= 0｜＜非零数字＞
  
  ＜非零数字＞  ::= 1｜．．．｜9

### 思路

- getsym()  内置一个while（(c = fgetc(IN)) != EOF）{}，只有当读到终止符跳出，不然一直读

- IN,OUT文件，token等等都可以定义在头文件中
- 遇到bug
  - 读字符串后误把指针往后移一位导致"asd"()会将(跳过
  - 读到文件尾部指针就不会动了，要注意，不然会导致错误

创建hashmap，token -> type， 知道token直接可以查询type（除了前四种）

## 语法分析

### 思路

- 每个语法成分都要写

- 语法成分有子程序分析时就调用子程序，不要管简不简单

- 每个语法成分进入时都已经多读一个词，每个语法成分退出时也多读了一个词供下个成分使用

- 语法分析中存在 | ，使用if区分，每个if条件根据每个|开头第一个单词区分，如果是个子语法成分则一层一层深入直到找到（如<声明头部>就继续深入最后找到int|char）

  有{}，靠{}内第一个词来引入循环，用do while

- error出现在自己的语法成分中，在一个语法成分中嵌套别的语法成分，不用管，别的成分error就在别的中error，只有确切的词（如VOIDTK等等的）才可以在自己的程序中直接定义error，不然就交给子程序

- 关于<空>，不用输出

  - 判断方法：我是读后一个符号是不是直接代表结束，如前一个是（，而后一个就是），那就是空

  







- 语法分析getsym函数在fprintf之后调用语法分析程序，传入每个单词

- 每个语法分析子程序结尾fprintf出识别的语法内容，有d于总程序是递归程序，因此fprintf出的内容也是按照顺序打出的

- 给出的文法虽然不是左递归，但是有回溯问题。需要将每个规则展开到**纯 | 的规则**来判断并且花间。还是使用预读方法，借鉴getsym的写法但是记录向前读了多少，判断成功后返回多少

  注意我们这里最小单位是一个**词**，而不是一个符
  
- 注意：
  1、请注意语法成分信息与单词信息的前后顺序，尤其是在分界处。如“int a;”，当
  读完“int a”后应当输出 < 变量定义 >；继续读完“;”后，如果后面不再有变量定义语
  句，应当输出 < 变量说明 >。要着重注意 < 变量定义 > 和“;”的前后输出顺序，在实
  现程序中，我们往往在退出 < 变量定义 > 的子程序时，当前单词 token 中存的是下一个
  单词，即“;”，如果将单词输出放在词法分析阶段，就可能会导致先输出“;”的单词信
  息，后输出 < 变量定义 > 的语法成分信息的情况，从而导致错误

  - 解决：getsym不输出， 在词法分析中输出（getAndPrint）。每次getsym是把上次的打印出来并把这次的读入？

    先读出词并打印，然后分析语法结构。对于底层直接结尾有getAndPrint的函数，应该将fprintf放在getAndPrint的下面，getAndPrint打印当前的词，然后fprintf再打印语法。
  
    对于高层函数，我们可以想象每个子程序结尾都是多读一个词，它是不属于这个语法的，
  
- 最外层每个if对应于每个 | 分成的大情况，里层的if对应于每个大情况中的按顺序进行检查

```c








＜程序＞    ::= ［＜常量说明＞］［＜变量说明＞］{＜有返回值函数定义＞|＜无返回值函数定义＞}＜主函数＞
!!![const][int|char]{int|char|void}void

＜常量说明＞ ::=  const＜常量定义＞;{ const＜常量定义＞;}


＜常量定义＞   ::=   int＜标识符＞＝＜整数＞{,＜标识符＞＝＜整数＞}

                  | char＜标识符＞＝＜字符＞{,＜标识符＞＝＜字符＞}



＜声明头部＞   ::=  int＜标识符＞ |char＜标识符＞


＜变量说明＞  ::= ＜变量定义＞;{＜变量定义＞;}

＜变量定义＞  ::= ＜类型标识符＞(＜标识符＞|＜标识符＞'['＜无符号整数＞']'){,(＜标识符＞|＜标识符＞'['＜无符号整数＞']' )}
!!!先识别标识符，再识别有没有[或{
                 //＜无符号整数＞表示数组元素的个数，其值需大于0

＜类型标识符＞      ::=  int | char

＜有返回值函数定义＞  ::=  ＜声明头部＞'('＜参数表＞')' '{'＜复合语句＞'}'
＜无返回值函数定义＞  ::= void＜标识符＞'('＜参数表＞')''{'＜复合语句＞'}'
＜复合语句＞   ::=  ［＜常量说明＞］［＜变量说明＞］＜语句列＞

＜参数表＞    ::=  ＜类型标识符＞＜标识符＞{,＜类型标识符＞＜标识符＞}| ＜空＞
＜主函数＞    ::= void main‘(’‘)’ ‘{’＜复合语句＞‘}’

＜表达式＞    ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}   //[+|-]只作用于第一个<项>
＜项＞     ::= ＜因子＞{＜乘法运算符＞＜因子＞}
＜因子＞    ::= ＜标识符＞｜＜标识符＞'['＜表达式＞']'|'('＜表达式＞')'｜＜整数＞|＜字符＞｜＜有返回值函数调用语句＞         
＜语句＞    ::= ＜条件语句＞｜＜循环语句＞| '{'＜语句列＞'}'| ＜有返回值函数调用语句＞; 
                           |＜无返回值函数调用语句＞;｜＜赋值语句＞;｜＜读语句＞;｜＜写语句＞;｜＜空＞;|＜返回语句＞;

＜赋值语句＞   ::=  ＜标识符＞＝＜表达式＞|＜标识符＞'['＜表达式＞']'=＜表达式＞
＜条件语句＞  ::= if '('＜条件＞')'＜语句＞［else＜语句＞］
＜条件＞    ::=  ＜表达式＞＜关系运算符＞＜表达式＞ //整型表达式之间才能进行关系运算

       ｜＜表达式＞    //表达式为整型，其值为0条件为假，值不为0时条件为真                                             

＜循环语句＞   ::=  while '('＜条件＞')'＜语句＞| do＜语句＞while '('＜条件＞')' |for'('＜标识符＞＝＜表达式＞;＜条件＞;＜标识符＞＝＜标识符＞(+|-)＜步长＞')'＜语句＞
＜步长＞::= ＜无符号整数＞  
＜有返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'
＜无返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'
＜值参数表＞   ::= ＜表达式＞{,＜表达式＞}｜＜空＞
＜语句列＞   ::= ｛＜语句＞｝
＜读语句＞    ::=  scanf '('＜标识符＞{,＜标识符＞}')'
＜写语句＞    ::= printf '(' ＜字符串＞,＜表达式＞ ')'| printf '('＜字符串＞ ')'| printf '('＜表达式＞')'
＜返回语句＞   ::=  return['('＜表达式＞')']   
```



## 错误处理

### tip

- **表达式为char**
  
  表达式类型为char型有以下三种情况，需要包括char型数组的元素：
  （１）表达式由<标识符>或＜标识符＞'['＜表达式＞']构成，且<标识符>的类型为char，即char类型的常量和变量、char类型的数组元素。
  （２）表达式仅由一个<字符>构成，即字符字面量。
  （３）表达式仅由一个有返回值的函数调用构成，且该被调用的函数返回值为char型
  即，<表达式> ::*= <标识符>|＜标识符＞'['＜表达式＞'] | <有返回值函数调用语句> | <字符>，该标识符在作用域内为char类型，有返回值调用语句返回char型，:*=表示经过多步推导
  
  **其它时候表达式为int**
  
- c语言变量的作用域

  局部变量：函数内部，其中形参也是局部变量，相当于实参赋值给局部变量

  全局变量：整个程序，加上static就是只作用这段代码

  命名：

  - 不同函数内部可以出现同名的变量，因为不同函数是不同作用域；

    即**不同局部变量同名**

  - 函数内部和外部可以出现同名的变量，函数内部是局部作用域，函数外部是全局作用域。

    即**全局变量和局部变量同名**

  - 不同函数内部的同名变量是两个完全独立的变量，它们之间没有任何关联，也不会相互影响。

  - 函数内部的局部变量和函数外部的全局变量同名时，在当前函数这个局部作用域中，全局变量会被“屏蔽”，不再起作用。也就是说，在函数内部使用的是局部变量，而不是全局变量。

    **就近原则**

  - 综上  ------》 只要作用域不同就可以同名

  ​			

### 思路

![1572165410475](E:\北航\北航大三\编译技术\理论作业\1572165410475.png)

a：词法分析   ok

主词法程序中遇到非法字符就报错；

子语法程序，标识符识别

 不符合词法的情况包括：
\1. 出现词法规则里不允许出现的符号
\2. 在定义字符的时候，同一行中没有找到配对的右单引号
\3. 在定义字符串的时候，同一行中没有找到配对的右双引号

其他只要在词法分析中能正确识别的，都在语法分析中进行进一步判断是否符合相应的语法规则           

问题： printf(");如何识别                             

b：符号表找自身作用域有无重复即可，注意函数名和变量名一块在**自身作用域**查找，类似于下代码

```c
#include<stdio.h>
void a(){
	printf("a");
}
	
int main(){
		int a;
		a = 1;
		printf("ok");
            return 0;
} 
```

这是正确的不会报错，a在定义时在自身作用域(主函数)中未有重复，当把int a;  移到主函数外就会报错，因为在都在全局中。



c：符号表找自己作用域，找不到找全局 ok

d：符号表查询函数参数个数，在值参数表中记录参数个数 

e：符号表查询函数参数类型，符号表查询参数类型，如果是表达式则按照tip中表达式类型判断匹不匹配

​		关键是表达式类型确定

f：条件判断在判断符两边只能整型比较，如果没有判断符也只能是整型

g：符号表查找到是无返回值函数，在无返回值函数定义中若出现return则错误，并在函数结束行报错

h：只要有一条返回语句就不缺少，不匹配的return需要计算return的表达式和定义的函数返回值是否相符合

i：依然是判断是否为整型表达式

j：赋值语句查符号表是否改变的是常量 ok

k：语法检查中缺分号 ok   

l：语法检查中缺右小括号 ok

m：语法检查中缺右中括号 ok

n：语法检查缺while   ok

o：表达式检查 ok

p：因子缺失 

- 词法错误

  读到非法符号，传到语法程序中的就是空串，，会引发语法错误，不过由于对于单词的语法错误都能一个error之后就跳过了

- 关于符号表建立 

  vector<struct> 作为结构 ，大部分共同信息组成统一格式的符号表，
  特殊信息另设附表,两者用指针连接（如函数的参数部分就可以在主struct引出指针到附表中）。

  同时建立非分程序符号表，分全局变量表和局部变量表两张大表，局部变量表每统计完一个域就会刷新
  
  统计    变量、常量、函数、数组
  
  全局:全局常量，全局变量，函数名，
  
  局部：函数定义时：形参，局部常量和变量
  
  ​			主函数：局部常量和变量
  
  符号表信息：kind（var,const,array，fun ） 名字  type（int，char）
  
  插入符号表信息传入最好分开建立函数以方便附表建立
  
  - 如何确定是全局还是局部，设置isglobal参数，复合语句中isglobal=0，其它为1。 值参数表中为局部，函数定义为全局
  
- 跳过问题

  当跳过分号等符号时，getAndPrint得失效，此时recall也得位置更改，因为往后多读了一位相当于

  - 换行

    当已经读到换行符，line++时候，然而语法分析程序中错误处理时line其实还未变换。

    此时设置changeLine来确定是否是在换行间隙

- ​	b = f(;

  首先会因子缺失，然后缺右括号，

### 问题

- 某行多错误，使行数打印错误

  changeline在词法分析中每当刚刚换行就为CHANGED表示刚刚换行

- 表达式类型判断

  初始为char，一旦有int就变为int

- 函数参数个数和类型匹配

  先匹配个数，再类型

- 某个符号未定义，又得检查它的类型以便检查表达式的类型

  默认未定义符号为char型

- table_name 等等全局变量的使用危险

  全部换成局部变量

## mips生成

### 思路

- 中间代码

  ![1573562739625](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573562739625.png)

  ![1573562748518](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573562748518.png)

  最笨得到中间代码办法，每一条语句，用中间代码把它全部搞定，和后面语句没有任何关系（寄存器也全部清空）

- 函数调用

  ![1573566862369](C:\Users\GY\AppData\Roaming\Typora\typora-user-images\1573566862369.png)

  运行栈中需要返回地址、除$4-$8剩下的传入参数、局部变量等等

  函数参数传入靠$4-$8和运行栈参数存储

  函数内定义的局部变量存入运行栈

  函数返回靠$31

  具体规范是我们编译者自己定的，因为我们只要保证语义不变即可

- 关于地址空间

  地址空间的实现就是靠符号表中记录的地址信息

- 各种优化的理解

  其实就两个，对中间代码的简化【消除公共表达式、全局优化消除死代码等等】

  和对寄存器的分配【全局寄存器、临时寄存器】

- 对寄存器的分配

  - 全局寄存器

    如果不分配，每次都要取地址，分配了，这个寄存器就在全局（**函数内**）代表了这个变量而再也不需要取地址【就像以前mips作业，不会直接给变量开内存，能用寄存器表示就用寄存器】【为什么全局是在函数内呢，因为全局变量、静态变量不参与全局寄存器分配，而我们函数内变量作用范围又只有函数内变量和全局变量】。

  - 临时寄存器

- 中间代码生成

  不同的label可以在中间代码中就生成

  表达式中间代码就是用一个临时变量存储

  无返回值函数结尾加ret

  函数调用就函数调用，push和call即可，返回值存在寄存器中，只有当要用到返回值时用ret就行

  - 表达式中exp，term，factor传它代表的临时标号,内部建立的临时符号都可以舍弃，只留下最后传出来的符号

    临时变量生命周期只有一条语句，每条语句后清空即可

    我在expression和term中设置用完在中间的临时变量清空，在每条语句后设置清空所有临时变量

- 中间代码 ---》 mips

  全局常量

  全局变量

  函数定义{局部常量，局部变量}

  主函数{局部常量，局部变量}

   

  而mips用于存储的和计算的也就两个结构：内存、寄存器

   

  - data.段，划分出静态数据区、运行栈区

  - 首先读到全局量，直接存在静态数据区

  - 读到函数声明，定义

    - 生成独一无二的label以供调用

    - 我们的前提是1.所有之前寄存器的值都已经保存好了（如何保证所有被使用的寄存器被保存同时又不是机械的把所有寄存器全部存一边）2. jr指令已经将返回地址保存在$31 3.实参存在$a中，大于四的参数在这个运行栈底 。

    - 给实参、局部变量、常量、分配寄存器和地址（分配策略暂时不清楚）（地址实际上就是符号表上的地址，这个地址是相对地址，相对于当前运行栈，它这个地址是独一无二存在的，你可以填入即保存了，也可以不写入，但一直存在），符号表记录是否分配寄存器（32不分配，<32表示分配的寄存器）

    - 在运算时，遇到临时变量（区别于正常标识符）也需要识别出来放到符号表中，地址是临时变量存储地址，分配临时寄存器

    - 遇到其它函数调用，将所有寄存器的值填回栈中，返回地址填回，将栈指针移到新的栈中，将形参传入，如果大于4则填入新栈中

      调用结束，根据符号表中每个量（包括临时变量）的寄存器分配值回填到寄存器中，继续计算，返回地址也填入$31

    - 返回时，j $31

  - 主函数和普通函数一样

  - 每条中间代码前加上标识数字表示什么语句
  
    语句汇总
  
    - var int/char 全局变量声明
  
      变量名:.word 
  
      读取：lw $t, 变量名
  
      若是数组
  
    - const int/char  a = 10 全局常量声明
  
      常量名:.word 常量值
  
      读取：lw $t, 常量名
  
    - int fun ( t ) 函数定义
  
      1.输出标签
  
      fun:
  
      2.入全局符号表 只需要记录参数个数（因为函数名字只需要用来看参数个数是否大于4来push和pull参数）（中间代码最好传出个数）
  
      
  
      4.建立局部符号表，此时为空
  
    - para int a 形参定义
  
      1.入局部符号表，并记录其运行栈地址，用offset（相对于栈底$sp的偏移）
  
      2.将实参传入
  
      sw $a，offset($sp)
  
      大于四的已经在push中压入
  
    - const int/char  a = 10 常量声明
  
      1.入局部符号表，并记录其运行栈地址，用offset（相对于栈底$sp的偏移）
  
      2.传入值
  
      li $t8, 值
  
      sw $t8，offset($sp)
  
    - var int/char 变量声明
  
      1.入局部符号表，并记录其运行栈地址，用offset（相对于栈底$sp的偏移）
  
    - push x 传参
  
      局部符号表压栈（最好有中间代提醒压栈）
  
      压栈，被使用的寄存器压进去，而数组不用，因为数组在运算过程中一直存在地址中，那些没分到全局寄存器的变量也不用，它们也一直在地址运算
  
      运行栈指针偏移  准备用$sp当作运行栈指针，刚开始得赋值
  
      la $sp, stack
  
      $sp指针一直指的是栈底，新建栈栈底就得 addi $sp, $sp, globalIndex
  
       move $a0，x
  
      用pushAmount记录是否大于四，大于则移到新栈+16偏移处开始存参数
  
    - call fun 调用函数
  
      jr 函数名
  
    - RET	函数返回
  
      jr $ra
  
    - a = b sign c	运算 \ 可能含数组 \ 局部变量 \ 全局变量 \ 常量
  
      常量？ -》 局部？ -》 全局？ 
  
      变量  = 变量 sign 变量 
  
      数组只会单独出现在一头  a[1] = t 或 t = a[1]
  
      判断常量只要考虑开头是不是 ‘ 或者 数字
  
      等号左侧：传出地址或者寄存器，if(index >= 0) lw 右侧寄存器 ，偏移 else move 左侧寄存器，右侧寄存器 
  
      等号右侧：
  
    - a = b 赋值
    
    - x == y 判断
    
    - goto label 直接跳转
    
    - bnz label  判断跳转
    
    - read 读取
    
    - printf 输出
    
    
    
    数据结构
    
    map<string, int>  mid_table;
    //	符号表  名 -》 偏移  记录参数值，全局寄存器，局部变量，临时变量，返回值
    map<string, int> mid_globalReg;
    //	全局寄存器表 名 -》 $s
    map<string, int> mid_partReg;
    //	临时寄存器表	名 -》 $t
  
  

### 问题

- 中间代码到mips是否可以分开，那么符号表等等信息该如何存储

- 函数调用如何实现

  不需要存代码地址，有label就行

- 临时变量(t)如何生成，是否要计入符号表，内存怎么分配

- 优化为何要分成 基本块

- 临时变量分配和其下标不匹配会不会在临时寄存器分完后分不到

- 数组下标是表达式

## 软件配置

- [Microsoft Visual Studio](https://baike.baidu.com/item/Microsoft Visual Studio)（简称VS）是美国[微软公司](https://baike.baidu.com/item/微软公司)的开发工具包系列产品。VS是一个基本[完整](https://baike.baidu.com/item/完整/32785)的开发工具集，它包括了整个[软件生命周期](https://baike.baidu.com/item/软件生命周期/861455)中所需要的大部分工具，如UML工具、代码管控工具、[集成开发环境](https://baike.baidu.com/item/集成开发环境/298524)(IDE)等等。

- *Clang*是一个C语言、C++、Objective-C语言的轻量级编译器。源代码发布于BSD协议下。*Clang*将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。   
- *LLVM*是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本


